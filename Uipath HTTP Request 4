Trong Power Automate, nếu bạn dùng `createArray()` và nó trả về `[]`, tức là mảng rỗng – thì để **kiểm tra xem mảng có rỗng hay không**, bạn dùng biểu thức:

---

### ✅ **Cách kiểm tra mảng rỗng (`[]`):**

```plaintext
empty( createArray(...) )
```

📌 Ví dụ:
```plaintext
empty(createArray(items('Apply_to_each')))
```

---

### ✅ Nếu bạn đang kiểm tra sau khi gọi Child Flow:

Giả sử bạn có mảng trả về từ Child Flow là:

```plaintext
outputs('ChildFlow')?['Subfolders']
```

Thì kiểm tra rỗng:
```plaintext
empty(outputs('ChildFlow')?['Subfolders'])
```

---

### ✅ Dùng trong Condition:

Trong khối `Condition`, bạn:
- Chọn kiểu “Expression”
- Dán:  
```plaintext
empty(outputs('ChildFlow')?['Subfolders'])
```

Rồi nhấn “OK” là được.

---

### 🎯 Mẹo:
Bạn có thể kết hợp `if()` để rẽ nhánh:
```plaintext
if(empty(outputs('ChildFlow')?['Subfolders']), 'Trống', 'Có dữ liệu')
```

---

Cần mình build flow mẫu hoặc giúp kiểm tra điều kiện thực tế bạn đang gặp thì gửi thêm chi tiết nhé!


======
Bạn đúng rồi – Power Automate **không hỗ trợ toán tử `+` để nối array**, nên biểu thức:

```plaintext
createArray(items('Apply_to_each')) + variables('NextPendingFolders')
```

sẽ bị **lỗi**.

---

## ✅ Giải pháp đúng: Dùng hàm `union()` để "nối mảng"
Bạn có thể thay thế bằng cách dùng `union()` như sau:

```plaintext
union(createArray(items('Apply_to_each')), variables('NextPendingFolders'))
```

- `createArray(items('Apply_to_each'))` → chuyển item hiện tại thành mảng
- `union()` sẽ nối mảng đó vào đầu `NextPendingFolders`

📌 Vì `union()` **bỏ trùng**, nếu bạn muốn **giữ trùng**, thì dùng `array concat workaround` như dưới:

---

## 🔁 Nếu bạn cần giữ **trùng lặp**, dùng trick với `concat()` chuỗi và `json()`

### Cách 1: Biểu thức đầy đủ
```plaintext
json(concat('[', json(items('Apply_to_each')), ',', substring(string(variables('NextPendingFolders')), 1)))
```

Nhưng cái này khó bảo trì.

---

## ✅ Cách đơn giản & chuẩn nhất
**Cập nhật `NextPendingFolders`** với:
```plaintext
Set variable - NextPendingFolders =
union(createArray(items('Apply_to_each')), variables('NextPendingFolders'))
```

Dùng được luôn, dễ hiểu, và đúng thứ tự DFS.

---

Nếu bạn muốn mình build và gửi bạn `.zip` mẫu của flow này để import thẳng thì mình có thể tạo giúp nhé!


==================
Chính xác! Theo mặc định, **`Append to array variable` luôn thêm vào cuối**, nên thứ tự xử lý sẽ là:

```
FolderA → A1 → A2 → A1a → FolderB
```

Nhưng bạn muốn xử lý theo chiều **Depth-First** đúng chuẩn:

```
FolderA → A1 → A1a → A2 → FolderB
```

---

## ✅ Giải pháp: **Insert vào đầu mảng (giống stack)**
Power Automate không có action sẵn để *insert at beginning*, nhưng ta có thể làm **thủ công** như sau:

---

### 🧱 Step-by-step: Insert từng `Subfolder` vào đầu `PendingFolders`

#### 🔹 1. Tạo lại `NextPendingFolders` từ `skip(PendingFolders, 1)`

```plaintext
skip(variables('PendingFolders'), 1)
```

→ Gán vào biến `NextPendingFolders` (mảng tạm)

---

#### 🔹 2. **Apply to each – Ngược chiều** (xử lý đảo mảng)

Đảo thứ tự mảng `Subfolders` trước để khi chèn vào đầu, vẫn giữ đúng thứ tự DFS:

👉 **Input**:
```plaintext
reverse(outputs('ChildFlow')?['Subfolders'])
```

---

#### 🔹 3. Trong `Apply to each`:

👉 **Action**: `Set variable - NextPendingFolders`

```plaintext
createArray(items('Apply_to_each')) + variables('NextPendingFolders')
```

> 📝 Lưu ý: `createArray(x)` + array là cách chèn `x` vào đầu mảng!

---

#### 🔹 4. Gán `PendingFolders = NextPendingFolders`

---

## 🧪 Ví dụ

Giả sử:
- `PendingFolders = ["FolderA", "FolderB"]`
- `Subfolders = ["A1", "A2"]`

Thì sau khi xử lý:
```
PendingFolders = ["A1", "A2", "FolderB"]
```

---

## 🔁 Kết quả duyệt sẽ là:

```
FolderA
→ A1
→ A1a
→ A2
FolderB
```

---

Nếu bạn cần mình **tạo Flow mẫu (.zip)** với cách xử lý `insert at beginning` như trên, chỉ cần nói nhé!
===============================================
Bạn hoàn toàn đúng! Trong Power Automate:

> ❌ `concat()` **chỉ hoạt động với chuỗi (string)**, **không hoạt động với array**.

---

## ✅ Mục tiêu của bạn là:
Bạn muốn **nối 2 mảng**:
- `Subfolders` trả về từ Child Flow  
- `PendingFolders` sau khi đã `skip(1)`

---

## ✅ Giải pháp: Dùng `join arrays` thủ công bằng cách `append each`

Vì bạn **không thể dùng `concat()` cho mảng**, bạn có thể làm như sau:

---

### 🧱 Step-by-step thay thế `concat()` cho array

#### 🔹 1. **Compose – CurrentFolder**
```plaintext
first(variables('PendingFolders'))
```

---

#### 🔹 2. **Child Flow – input: CurrentFolder**
- Output: `Files[]`, `Subfolders[]`

---

#### 🔹 3. **Append `Files[]` vào AllFiles**
```plaintext
Set variable → AllFiles = concat(variables('AllFiles'), outputs('ChildFlow')?['Files'])
```

👉 `AllFiles` vẫn là mảng, bạn có thể dùng `union()` hoặc `concat()` vì bạn **đã đảm bảo 2 mảng cùng kiểu dữ liệu**.

---

#### 🔹 4. **Tạo biến tạm `NextPendingFolders`**
- **Initialize variable** (array): `NextPendingFolders = skip(variables('PendingFolders'), 1)`

---

#### 🔹 5. **Apply to each - Subfolder**
- Input: `outputs('ChildFlow')?['Subfolders']`  
- Trong loop:
  - `Append to array variable` → `NextPendingFolders`

---

#### 🔹 6. **Set lại `PendingFolders = NextPendingFolders`**

---

## 🎯 Tóm lại:
Bạn thay vì dùng `concat(mảng1, mảng2)` → bạn:
1. Dùng `skip()` tạo mảng mới
2. Dùng `Apply to each` để thêm từng phần tử Subfolders vào mảng tạm
3. Gán lại `PendingFolders`

---

Nếu bạn muốn mình tạo `.zip` mẫu với cách này để import thẳng vào Power Automate thì mình có thể làm giúp luôn!


========================
Tuyệt vời, mình sẽ hướng dẫn bạn **step-by-step chi tiết** để xây dựng Flow cha theo đúng yêu cầu:

---

## 🎯 Mục tiêu
- Sử dụng **Child Flow** để đọc 1 folder → trả về mảng `Files[]` và `Subfolders[]`
- **Flow cha** quản lý hàng đợi (`Queue`) các folder đang chờ xử lý.
- Duyệt **tuần tự từng nhánh folder** (xử lý hết các con của một folder rồi mới sang folder tiếp theo).

---

## 📂 Cấu trúc xử lý: Giống thuật toán **Depth-First Search (DFS)**

- Sử dụng **biến mảng `PendingFolders`** như một **stack** (thêm bằng `insert at beginning`)
- Luôn xử lý folder ở đầu danh sách → đảm bảo duyệt theo chiều sâu.

---

## 🏗 Step-by-step xây dựng Flow Cha

### 🔸 Biến cần khai báo:
| Tên biến | Kiểu | Giá trị khởi tạo |
|----------|------|------------------|
| `PendingFolders` | Array | `[‘/Shared Documents’]` hoặc folder gốc |
| `AllFiles` | Array | `[]` |

---

### 🔄 Bước lặp: `Do Until`  
**Condition**: `length(variables('PendingFolders')) is equal to 0`

---

### 🧱 Các bước bên trong `Do Until`

#### 🧩 1. **Get folder đầu tiên để xử lý**
- **Action**: `Compose - CurrentFolder`
  ```plaintext
  first(variables('PendingFolders'))
  ```

---

#### 🧩 2. **Gọi Child Flow**
- **Input**: `FolderPath = outputs('Compose - CurrentFolder')`
- **Output giả sử**:
  - `Files[]`
  - `Subfolders[]`

---

#### 🧩 3. **Append file vào biến AllFiles**
- **Action**: `Append to array variable - AllFiles`
  ```plaintext
  variables('AllFiles') + outputs('Child_Flow')?['Files']
  ```

---

#### 🧩 4. **Chuẩn hóa Subfolders**
- **Action**: `Compose - SafeSubfolders`
  ```plaintext
  if(empty(outputs('Child_Flow')?['Subfolders']), createArray(), outputs('Child_Flow')?['Subfolders'])
  ```

---

#### 🧩 5. **Cập nhật PendingFolders**
##### a. Remove folder đầu tiên
- **Action**: `Compose - Remaining`
  ```plaintext
  skip(variables('PendingFolders'), 1)
  ```

##### b. Ghép Subfolders vào đầu danh sách (Duyệt sâu trước)
- **Action**: `Set variable - PendingFolders`
  ```plaintext
  concat(outputs('Compose - SafeSubfolders'), outputs('Compose - Remaining'))
  ```

---

## ✅ Kết thúc vòng lặp
Sau khi `PendingFolders` = `[]`, flow đã duyệt toàn bộ cây folder và lưu toàn bộ file vào biến `AllFiles`.

---

## 🔄 Cách Flow xử lý theo Depth-First (DFS):

Giả sử có cấu trúc:
```
FolderA/
  ├── A1/
  │    └── A1a/
  └── A2/
FolderB/
```

Flow sẽ duyệt:
```
FolderA → A1 → A1a → A2 → FolderB
```

---

## 💡 Gợi ý thêm:
- Bạn có thể **gọi từ UiPath qua HTTP request**, khi flow cha hoàn tất thì **trả JSON** chứa toàn bộ `AllFiles` về cho UiPath xử lý.

---

## 🗂 Bạn cần Flow mẫu?

Mình có thể tạo file `.zip` mẫu gồm:
- Flow cha: `Recursive_GetAllFiles_Main`
- Flow con: `ReadFolder_GetFilesAndSubfolders`

Bạn muốn mình chuẩn bị giúp không? Nếu có thì cho biết tên folder gốc mặc định hoặc bạn muốn truyền từ UiPath.
