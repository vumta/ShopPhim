Cảm ơn bạn đã phản hồi! 🛠️  
Đúng rồi, phần khai báo kiểu `[string, string[][]][]` sẽ gây lỗi trong **Office Script**, vì TypeScript trong môi trường Office Script **không hỗ trợ tuple array khai báo kiểu phức tạp như vậy**.

---

## ✅ Cách sửa phù hợp với Office Script

Bạn nên thay thế bằng khai báo **object** đơn giản hơn, ví dụ:

```ts
type ColumnData = {
  columnName: string;
  values: string[][];
};
```

Sau đó, kiểu dữ liệu sẽ là:

```ts
ColumnData[]
```

---

## ✅ Cập nhật lại hàm Office Script tương thích

### 🔁 **Hàm trích xuất từ file nguồn (đọc dữ liệu)**

```ts
function main(workbook: ExcelScript.Workbook, columnNames: string[]): ColumnData[] {
  const sheet = workbook.getActiveWorksheet();
  const values = sheet.getUsedRange().getValues();

  const headers = values[0] as string[];
  let result: ColumnData[] = [];

  for (let name of columnNames) {
    const colIndex = headers.indexOf(name);
    if (colIndex === -1) continue;

    const columnValues = values.slice(1).map(row => [String(row[colIndex])]);
    result.push({
      columnName: name,
      values: columnValues
    });
  }

  return result;
}

type ColumnData = {
  columnName: string;
  values: string[][];
};
```

---

### 🔁 **Hàm ghi vào file đích theo tên cột dòng 2**

```ts
function main(workbook: ExcelScript.Workbook, inputData: ColumnData[]) {
  const sheet = workbook.getActiveWorksheet();
  const headerRow = 2;
  const startRow = 3;

  const headers = sheet.getRange(`A${headerRow}:Z${headerRow}`).getValues()[0] as string[];
  const colMap: Record<string, number> = {};

  headers.forEach((name, i) => {
    if (name) colMap[String(name).trim()] = i;
  });

  const rowCount = inputData[0].values.length;

  for (let i = 0; i < rowCount; i++) {
    for (let column of inputData) {
      const colIndex = colMap[column.columnName];
      if (colIndex !== undefined) {
        sheet.getCell(startRow - 1 + i, colIndex).setValue(column.values[i][0]);
      }
    }
  }
}

type ColumnData = {
  columnName: string;
  values: string[][];
};
```

---

### ✅ Ưu điểm cách dùng `object`:

- Dễ đọc, dễ mở rộng (có thể thêm `dataType`, `format`, v.v. sau này).
- Dễ thao tác trong Power Automate.
- Tương thích hoàn toàn với Office Script.

---

Bạn muốn mình giúp thêm phần **Parse JSON mẫu cho kiểu `ColumnData[]` này** để dùng trong Power Automate không?


Rất thực tế luôn! Việc kiểm tra `getUsedRange()` có trả về `null` hay không là **rất quan trọng** trong Office Script, vì nếu bạn cố gọi `.getValues()` trên `null` thì script sẽ lỗi ngay.

---

## ✅ Cách kiểm tra `getUsedRange()` có trả về `null` hay không

### 🔸 Cách viết an toàn:

```ts
const usedRange = sheet.getUsedRange();

if (!usedRange) {
  console.log("Sheet không có dữ liệu!");
  return; // hoặc return [] nếu đang trong hàm trả dữ liệu
}
```

- `getUsedRange()` sẽ **trả về `undefined`** hoặc **`null`** nếu **không có ô nào trong sheet chứa dữ liệu hoặc định dạng.**
- Dù hiếm gặp, vẫn nên kiểm tra để tránh lỗi runtime.

---

### 🔸 Cách đầy đủ khi muốn lấy `values`:

```ts
const usedRange = sheet.getUsedRange();

if (!usedRange) {
  console.log("Không có vùng dữ liệu được sử dụng!");
  return [];
}

const values = usedRange.getValues();
```

---

## ✅ Hoặc viết gọn bằng toán tử `?`:

Nếu bạn không chắc `getUsedRange()` tồn tại và muốn viết gọn, bạn có thể dùng toán tử an toàn (`?.`):

```ts
const values = sheet.getUsedRange()?.getValues() ?? [];
```

- `?.` sẽ kiểm tra `getUsedRange()` có null không trước khi gọi `getValues()`.
- `?? []` đảm bảo nếu kết quả là `undefined` thì bạn vẫn có giá trị mặc định là mảng rỗng.

---

## ✅ Một gợi ý khác – Dự phòng nếu `getUsedRange()` không đủ tin cậy

Nếu file bạn xử lý đôi khi có "vùng trắng" hoặc dữ liệu nằm ngoài vùng Excel coi là "used", bạn có thể xử lý thủ công:

```ts
const values = sheet.getRange("A1:Z1000").getValues(); // giả định vùng lớn
```

Tuy nhiên, cách này có thể lấy cả nhiều ô trống không cần thiết – phù hợp nếu bạn biết chắc vùng dữ liệu nằm trong đó.

---

Bạn muốn mình viết cho bạn một **utility function `getSafeValues(sheet)`** để dùng lại nhiều lần không?


Bạn đang nói đến đoạn:

```ts
const usedRange = sheet.getUsedRange();
```

và thắc mắc về giới hạn (limit) của `getUsedRange()` – có lẽ bạn đang gặp phải tình huống:

- `getUsedRange()` không hoạt động như mong đợi.
- Hoặc bạn nghi ngờ có giới hạn số ô hoặc số dòng được trả về.

---

## ✅ Giải thích về `getUsedRange()` và các giới hạn

### 🔹 `getUsedRange()` làm gì?
- Trả về vùng bao gồm **tất cả các ô có dữ liệu hoặc định dạng**.
- Tự động xác định từ ô đầu tiên chứa dữ liệu đến ô cuối cùng.
- **Không cần chỉ định vùng cụ thể**, nó quét toàn sheet.

---

### 🔹 Có giới hạn không?

| Thuộc tính               | Giới hạn kỹ thuật |
|--------------------------|------------------|
| Tổng số dòng trong Excel | 1,048,576        |
| Tổng số cột              | 16,384 (cột XFD) |

> Tuy nhiên, `getUsedRange()` **chỉ trả về đúng phạm vi đang có dữ liệu/thay đổi**, nên **hiếm khi đụng giới hạn** trừ khi bạn xử lý file cực lớn.

---

## ❗ Các tình huống thực tế bạn có thể gặp:

### 1. `getUsedRange()` trả về `null` hoặc lỗi
- Sheet hoàn toàn trống, hoặc bạn vừa xóa hết dữ liệu nhưng chưa lưu file.
- Cần gọi `getUsedRange()` sau khi chắc chắn sheet có dữ liệu.

### 2. Bạn chỉ lấy được một phần dữ liệu (thiếu dòng/cột)
- Có thể có định dạng rác trong sheet khiến `UsedRange` bao gồm nhiều ô trống không ngờ tới.
- Hoặc dữ liệu nằm ngoài vùng bạn nghĩ (ví dụ: ở cột AZ hay dòng 2000).

---

## ✅ Cách kiểm tra phạm vi `UsedRange` đang bao gồm gì

Bạn có thể log vị trí hàng và cột:

```ts
const usedRange = sheet.getUsedRange();

if (!usedRange) {
  console.log("Không có dữ liệu được sử dụng.");
  return;
}

const rowCount = usedRange.getRowCount();
const columnCount = usedRange.getColumnCount();
const startRow = usedRange.getRowIndex();
const startColumn = usedRange.getColumnIndex();

console.log(`Used range bắt đầu từ dòng ${startRow + 1}, cột ${startColumn + 1}, kích thước ${rowCount} x ${columnCount}`);
```

> Excel sử dụng **chỉ số bắt đầu từ 0**, nên cần `+1` để ra đúng số dòng/cột theo mắt người.

---

## ✅ Nếu bạn muốn "giới hạn vùng dữ liệu" thủ công

Ví dụ: bạn chỉ muốn xử lý từ A1 đến H1000:

```ts
const range = sheet.getRange("A1:H1000");
const values = range.getValues();
```

---

## Bạn muốn gì tiếp theo?

- Mình có thể giúp bạn viết một **hàm `getActualDataRange()`** để tự động xác định vùng có dữ liệu thực (không bị ảnh hưởng bởi định dạng rác).
- Hoặc bạn có thể gửi cụ thể **bạn gặp lỗi gì khi dùng `getUsedRange()`**, để mình hỗ trợ đúng điểm bạn cần.

Cần mình hỗ trợ phần nào tiếp theo?
