D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n nhanh ‚Äî r√µ ‚Äî ch·∫°y ƒë∆∞·ª£c lu√¥n ƒë·ªÉ b·∫°n t·∫°o nhi·ªÅu folder v√† subfolder, k·ªÉ c·∫£ t√™n ch·ª©a k√Ω t·ª± ƒë·∫∑c bi·ªát/Unicode, b·∫±ng Excel + PowerShell. M√¨nh ƒë∆∞a 2 c√°ch: (A) xu·∫•t CSV (ƒë∆°n gi·∫£n, khuy·∫øn ngh·ªã) v√† (B) ƒë·ªçc tr·ª±c ti·∫øp file .xlsx qua COM (kh√¥ng c·∫ßn xu·∫•t). C√≥ th√™m h√†m sanitize ƒë·ªÉ t·ª± ƒë·ªông thay th·∫ø k√Ω t·ª± kh√¥ng h·ª£p l·ªá tr√™n Windows (\ / : * ? " < > |) n·∫øu c·∫ßn.

1) Chu·∫©n b·ªã Excel

Option 1 ‚Äî D√πng 1 c·ªôt ch·ª©a full path

Sheet v√≠ d·ª• (Sheet1): c·ªôt A header = Path


Path
C:\Projects\ƒê·ªÅ √°n A\T√†i li·ªáu\Phi√™n b·∫£n 1
C:\Projects\ƒê·ªÅ √°n A\T√†i li·ªáu\üìÅ K·∫ø ho·∫°ch
C:\Projects\ƒê·ªÅ √°n B\„Éá„Éº„Çø\„É¨„Éù„Éº„Éà

Option 2 ‚Äî D√πng nhi·ªÅu c·ªôt (Parent, Sub1, Sub2...)

Sheet:


Parent, Sub1, Sub2
C:\Projects, ƒê·ªÅ √°n A, T√†i li·ªáu
C:\Projects, ƒê·ªÅ √°n A, üìÅ K·∫ø ho·∫°ch
C:\Projects, ƒê·ªÅ √°n B, „Éá„Éº„Çø

L∆∞u √Ω khi xu·∫•t CSV: khi d√πng Option 1/2 n·∫øu xu·∫•t d√πng CSV, ch·ªçn "CSV UTF-8 (Comma delimited) (*.csv)" ƒë·ªÉ gi·ªØ Unicode (emoji, ti·∫øng Vi·ªát, ti·∫øng Nh·∫≠t...).


---

2) PowerShell ‚Äî C√°ch A: ƒë·ªçc t·ª´ CSV UTF-8 (khuy·∫øn ngh·ªã)

L∆∞u file Excel sang folders.csv (CSV UTF-8). D∆∞·ªõi ƒë√¢y script x·ª≠ l√Ω c·∫£ 2 ki·ªÉu CSV (full-path ho·∫∑c nhi·ªÅu c·ªôt):

# create-folders-from-csv.ps1
param(
    [string]$CsvPath = ".\folders.csv",
    [switch]$SanitizeNames  # d√πng ƒë·ªÉ thay k√Ω t·ª± kh√¥ng h·ª£p l·ªá
)

function Remove-InvalidWindowsChars([string]$name) {
    if ($null -eq $name) { return $name }
    $invalid = [System.IO.Path]::GetInvalidFileNameChars() + [System.IO.Path]::GetInvalidPathChars()
    $out = $name
    foreach ($c in $invalid | Select-Object -Unique) {
        $out = $out -replace [regex]::Escape($c), '-'   # thay b·∫±ng d·∫•u '-'
    }
    # trim whitespace ends
    return $out.Trim()
}

# Read CSV with UTF8
$rows = Import-Csv -Path $CsvPath -Encoding UTF8

foreach ($row in $rows) {
    if ($row.PSObject.Properties.Name -contains 'Path') {
        # CSV c√≥ c·ªôt "Path" ch·ª©a full path
        $target = $row.Path
    } else {
        # Nhi·ªÅu c·ªôt: n·ªëi c√°c c·ªôt kh√¥ng r·ªóng
        $parts = @()
        foreach ($p in $row.PSObject.Properties) {
            $val = $p.Value
            if (![string]::IsNullOrWhiteSpace($val)) {
                if ($SanitizeNames) { $val = Remove-InvalidWindowsChars $val }
                $parts += $val
            }
        }
        # N·∫øu ph·∫ßn ƒë·∫ßu ch·ª©a drive (vd C:\) th√¨ d√πng Join-Path ƒë·∫∑c bi·ªát
        if ($parts.Count -gt 0 -and $parts[0] -match '^[A-Za-z]:\\') {
            $root = $parts[0]
            $rest = $parts[1..($parts.Count-1)]
            $target = $root
            foreach ($r in $rest) { $target = Join-Path -Path $target -ChildPath $r }
        } else {
            # n·ªëi relative path
            $target = [System.IO.Path]::Combine($parts)
        }
    }

    if ($SanitizeNames) {
        # n·∫øu full path th√¨ sanitize t·ª´ng segment
        $segments = $target -split '\\'
        for ($i=0; $i -lt $segments.Count; $i++) {
            $segments[$i] = Remove-InvalidWindowsChars $segments[$i]
        }
        # ƒë·ªëi v·ªõi path b·∫Øt ƒë·∫ßu b·∫±ng drive (ex: C:) gi·ªØ l·∫°i d·∫•u \
        if ($target -match '^[A-Za-z]:') {
            $target = ($segments -join '\')
        } else {
            $target = ($segments -join '\')
        }
    }

    if (![string]::IsNullOrWhiteSpace($target)) {
        try {
            New-Item -ItemType Directory -Path $target -Force | Out-Null
            Write-Host "Created: $target"
        } catch {
            Write-Warning "Failed to create $target ‚Äî $($_.Exception.Message)"
        }
    }
}

Ch·∫°y: m·ªü PowerShell (Run as Administrator n·∫øu c·∫ßn), r·ªìi:

# v√≠ d·ª•:
.\create-folders-from-csv.ps1 -CsvPath "C:\path\to\folders.csv" -SanitizeNames


---

3) PowerShell ‚Äî C√°ch B: ƒë·ªçc tr·ª±c ti·∫øp .xlsx qua Excel COM (kh√¥ng c·∫ßn xu·∫•t CSV)

N·∫øu b·∫°n kh√¥ng mu·ªën xu·∫•t CSV, d√πng COM ƒë·ªÉ ƒë·ªçc .xlsx (Windows only, Excel ph·∫£i c√†i):

# create-folders-from-xlsx.ps1
param(
    [string]$ExcelPath = ".\folders.xlsx",
    [string]$SheetName = "Sheet1",
    [switch]$HasHeader = $true,
    [switch]$SanitizeNames
)

function Remove-InvalidWindowsChars([string]$name) {
    if ($null -eq $name) { return $name }
    $invalid = [System.IO.Path]::GetInvalidFileNameChars() + [System.IO.Path]::GetInvalidPathChars()
    $out = $name
    foreach ($c in $invalid | Select-Object -Unique) {
        $out = $out -replace [regex]::Escape($c), '-'
    }
    return $out.Trim()
}

$excel = New-Object -ComObject Excel.Application
$excel.Visible = $false
$wb = $excel.Workbooks.Open((Resolve-Path $ExcelPath).Path)
$ws = $wb.Worksheets.Item($SheetName)

# get used range
$used = $ws.UsedRange
$rowCount = $used.Rows.Count
$colCount = $used.Columns.Count

# determine start row
$startRow = 1
if ($HasHeader) { $startRow = 2 }

for ($r = $startRow; $r -le $rowCount; $r++) {
    # if first column is 'Path', treat as full path
    $firstCell = $ws.Cells.Item(1,1).Text
    $cells = @()
    for ($c = 1; $c -le $colCount; $c++) {
        $val = $ws.Cells.Item($r, $c).Text
        if (![string]::IsNullOrWhiteSpace($val)) { $cells += $val }
    }
    if ($cells.Count -eq 0) { continue }
    if ($firstCell -eq 'Path') {
        $target = $cells[0]
    } else {
        # join parts
        if ($cells[0] -match '^[A-Za-z]:\\') {
            $target = $cells[0]
            for ($i = 1; $i -lt $cells.Count; $i++) { $target = Join-Path -Path $target -ChildPath $cells[$i] }
        } else {
            $target = [System.IO.Path]::Combine($cells)
        }
    }

    if ($SanitizeNames) {
        $segments = $target -split '\\'
        for ($i=0; $i -lt $segments.Count; $i++) { $segments[$i] = Remove-InvalidWindowsChars $segments[$i] }
        $target = ($segments -join '\')
    }

    try {
        New-Item -ItemType Directory -Path $target -Force | Out-Null
        Write-Host "Created: $target"
    } catch {
        Write-Warning "Failed to create $target ‚Äî $($_.Exception.Message)"
    }
}

# cleanup
$wb.Close($false)
$excel.Quit()
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($ws) | Out-Null
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($wb) | Out-Null
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null
[GC]::Collect(); [GC]::WaitForPendingFinalizers()

Ch·∫°y:

.\create-folders-from-xlsx.ps1 -ExcelPath "C:\path\to\folders.xlsx" -SheetName "Sheet1" -SanitizeNames


---

4) V·∫•n ƒë·ªÅ k√Ω t·ª± ƒë·∫∑c bi·ªát / Unicode

Windows h·ªó tr·ª£ Unicode trong t√™n th∆∞ m·ª•c (ti·∫øng Vi·ªát, Nh·∫≠t, emoji...), mi·ªÖn l√† kh√¥ng d√πng c√°c k√Ω t·ª± c·∫•m: \ / : * ? " < > | v√† t√™n kh√¥ng ƒë∆∞·ª£c k·∫øt th√∫c b·∫±ng d·∫•u ch·∫•m ho·∫∑c kho·∫£ng tr·∫Øng cu·ªëi.

N·∫øu file Excel c√≥ emoji/kanji/full-width punctuation, CSV UTF-8 + Import-Csv -Encoding UTF8 ho·∫∑c COM Excel s·∫Ω gi·ªØ nguy√™n.

N·∫øu b·∫°n mu·ªën t·ª± ƒë·ªông thay th·∫ø k√Ω t·ª± c·∫•m b·∫±ng - ho·∫∑c _, b·∫≠t -SanitizeNames trong script ƒë·ªÉ tr√°nh l·ªói.



---

5) M·∫πo & troubleshooting

N·∫øu ch·∫°y script v√† kh√¥ng th·∫•y t·∫°o th∆∞ m·ª•c: ki·ªÉm tra quy·ªÅn (ch·∫°y PowerShell as Admin n·∫øu t·∫°o ·ªü C:\), ki·ªÉm tra ƒë∆∞·ªùng d·∫´n ƒë√∫ng.

N·∫øu g·∫∑p l·ªói encoding (k√Ω t·ª± b·ªã l·ªói): ch·∫Øc ch·∫Øn xu·∫•t CSV d∆∞·ªõi d·∫°ng CSV UTF-8.

N·∫øu Excel ƒëang m·ªü file .xlsx, COM script v·∫´n c√≥ th·ªÉ m·ªü; nh∆∞ng ƒë·ªÉ an to√†n, ƒë√≥ng file tr∆∞·ªõc khi ch·∫°y script.

Mu·ªën log k·∫øt qu·∫£ ra file: th√™m | Out-File -FilePath ".\create-log.txt" -Append -Encoding UTF8 ho·∫∑c d√πng Start-Transcript.



---

N·∫øu b·∫°n mu·ªën, m√¨nh c√≥ th·ªÉ:

T·∫°o s·∫µn file create-folders-from-csv.ps1 ho·∫∑c create-folders-from-xlsx.ps1 v·ªõi n·ªôi dung chu·∫©n ƒë·ªÉ b·∫°n download.

Ho·∫∑c ‚Äî n·∫øu b·∫°n d√°n v√†i d√≤ng v√≠ d·ª• t·ª´ Excel ·ªü ƒë√¢y ‚Äî m√¨nh s·∫Ω ch·ªânh script sao cho ph√π h·ª£p ch√≠nh x√°c v·ªõi c·∫•u tr√∫c c·ªßa b·∫°n.


B·∫°n mu·ªën m√¨nh t·∫°o file .ps1 cho b·∫°n hay c·∫ßn ch·ªânh theo ƒë·ªãnh d·∫°ng Excel c·ªßa b·∫°n (full-path hay nhi·ªÅu c·ªôt)?
