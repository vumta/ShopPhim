Cảm ơn — mình đã xem code và chỉnh lại để bắt nguyên nhân lỗi 0x800A9C68 đồng thời tăng tính vững chắc khi chạy trong cả Excel bình thường lẫn khi automation (UiPath...). Dưới đây là phiên bản sửa đổi, kèm giải thích nguyên nhân thường gặp và cách test nhanh.

Nguyên nhân thường gặp khiến lỗi 0x800A9C68 (SaveAs/Automation failed)

Tên file (dựa trên SheetName) chứa ký tự không hợp lệ cho file system (/:*?"<>|) hoặc quá dài → SaveAs thất bại.

Workbook mới vẫn chưa active/ready khi gọi SaveAs (thỉnh thoảng xảy ra khi automation).

Định dạng FileFormat không tương thích (ví dụ workbook có macro nhưng lưu .xlsx sẽ bị lỗi trên một số cấu hình).

xlCSVUTF8 hoặc hằng số enum không nhận trong một vài môi trường (dùng số tương ứng an toàn hơn).

File đang mở bởi process khác, hoặc không có quyền ghi vào folder.

Nếu chạy từ UiPath, dialog SaveAs xuất hiện hoặc Excel invisible — automation block.
Phiên bản dưới khắc phục các vấn đề trên: sanitize tên file, bắt lỗi chi tiết, thử fallback (nếu .xlsx fail thử .xlsm), force activate, sử dụng numeric constants cho FileFormat, ghi log vào file để dễ debug.



---

Code đã sửa — dán vào module .bas (thay thế module hiện tại)

Attribute VB_Name = "ExportSheetAsFile"

Option Explicit

' Numeric constants (an toàn khi enum không được nhận)
Private Const XL_OPENXML_WORKBOOK As Long = 51            ' .xlsx
Private Const XL_OPENXML_WORKBOOK_MACROENABLED As Long = 52 ' .xlsm
Private Const XL_CSV_UTF8 As Long = 62                     ' xlCSVUTF8

Public Sub ExportSheetAsFile(SheetName As String, OutputFolder As String, Optional FileFormat As String = "xlsx")
    On Error GoTo ErrHandler

    Dim wb As Workbook
    Dim ws As Worksheet
    Dim newWb As Workbook
    Dim FilePath As String
    Dim safeName As String
    Dim ext As String
    Dim attemptedFmt As Long
    Dim fso As Object
    Dim logPath As String
    
    logPath = Environ("TEMP") & Application.PathSeparator & "ExportSheetAsFile-log.txt"
    
    ' Kiểm tra folder tồn tại
    If Dir(OutputFolder, vbDirectory) = "" Then
        MsgBox "Thư mục không tồn tại: " & OutputFolder, vbExclamation
        Exit Sub
    End If
    
    ' Lấy workbook hiện tại
    Set wb = ThisWorkbook
    
    ' Kiểm tra sheet có tồn tại không
    On Error Resume Next
    Set ws = wb.Sheets(SheetName)
    On Error GoTo ErrHandler
    
    If ws Is Nothing Then
        MsgBox "Không tìm thấy sheet: " & SheetName, vbCritical
        Exit Sub
    End If
    
    ' --- sanitize sheet name -> an toàn làm file name ---
    safeName = MakeSafeFileName(SheetName)
    If Len(safeName) = 0 Then safeName = "SheetExport"
    ' tránh quá dài (reserve chỗ cho path)
    If Len(safeName) > 150 Then safeName = Left(safeName, 150)
    
    ' Copy sheet ra file mới
    ws.Copy ' tạo workbook mới có sheet được copy
    Set newWb = ActiveWorkbook
    
    ' đảm bảo active để tránh lỗi automation
    newWb.Activate
    DoEvents
    
    Select Case LCase(FileFormat)
        Case "csv"
            ext = ".csv"
            attemptedFmt = XL_CSV_UTF8
        Case "xlsm"
            ext = ".xlsm"
            attemptedFmt = XL_OPENXML_WORKBOOK_MACROENABLED
        Case Else
            ext = ".xlsx"
            attemptedFmt = XL_OPENXML_WORKBOOK
    End Select
    
    FilePath = OutputFolder & Application.PathSeparator & safeName & ext
    
    ' Nếu file đang tồn tại thì xóa (cẩn trọng) — tránh dialog overwrite
    On Error Resume Next
    Kill FilePath
    On Error GoTo ErrHandler
    
    ' Tắt alerts tránh popup, nhưng bật lại sau
    Application.DisplayAlerts = False
    Application.EnableEvents = False
    
    ' Thử lưu; nếu fail với .xlsx do macros inside, thì thử .xlsm
    On Error GoTo SaveError
    newWb.SaveAs Filename:=FilePath, FileFormat:=attemptedFmt
    GoTo SaveOK

SaveError:
    ' lưu thất bại — nếu định dạng là .xlsx thì thử .xlsm (trường hợp có macro trong sheet/objects)
    Dim saveErr As Long: saveErr = Err.Number
    Dim saveDesc As String: saveDesc = Err.Description
    Call AppendLog(logPath, "SaveAs failed for " & FilePath & " Err=" & saveErr & " Desc=" & saveDesc)
    
    If attemptedFmt = XL_OPENXML_WORKBOOK Then
        ' thử fallback sang xlsm
        FilePath = OutputFolder & Application.PathSeparator & safeName & ".xlsm"
        On Error GoTo ErrHandler
        newWb.SaveAs Filename:=FilePath, FileFormat:=XL_OPENXML_WORKBOOK_MACROENABLED
    Else
        ' không có fallback -> ném lỗi tiếp
        Err.Raise saveErr, , saveDesc
    End If

SaveOK:
    ' Đóng file mới
    newWb.Close SaveChanges:=False
    
    ' phục hồi
    Application.DisplayAlerts = True
    Application.EnableEvents = True
    
    MsgBox "Đã xuất sheet '" & SheetName & "' ra file: " & FilePath, vbInformation
    Exit Sub

ErrHandler:
    ' phục hồi nếu có
    On Error Resume Next
    Application.DisplayAlerts = True
    Application.EnableEvents = True
    AppendLog logPath, "ERR Handler: " & Err.Number & " - " & Err.Description & " (Sheet=" & SheetName & " OutputFolder=" & OutputFolder & ")"
    MsgBox "Lỗi khi xuất sheet. Err.Number=" & Err.Number & vbCrLf & "Err.Description=" & Err.Description & vbCrLf & "Xem log: " & logPath, vbCritical
    ' đóng workbook mới nếu còn mở
    If Not newWb Is Nothing Then
        On Error Resume Next
        newWb.Close SaveChanges:=False
    End If
End Sub

'--- Hàm thay thế ký tự không hợp lệ trong file name ---
Private Function MakeSafeFileName(nameIn As String) As String
    Dim i As Long, ch As String
    Dim out As String
    out = Trim(nameIn)
    ' loại bỏ/replace các ký tự không hợp lệ
    For i = 1 To Len(out)
        ch = Mid$(out, i, 1)
        Select Case ch
            Case "/", "\", ":", "*", "?", """", "<", ">", "|"
                out = Replace(out, ch, "_")
        End Select
    Next i
    ' loại bỏ các control characters
    Dim j As Long, cCode As Long, cleaned As String
    cleaned = ""
    For j = 1 To Len(out)
        cCode = AscW(Mid$(out, j, 1))
        If cCode >= 32 Then cleaned = cleaned & Mid$(out, j, 1)
    Next j
    MakeSafeFileName = cleaned
End Function

'--- Append log đơn giản ---
Private Sub AppendLog(path As String, msg As String)
    On Error Resume Next
    Dim fso As Object, ts As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set ts = fso.OpenTextFile(path, 8, True)
    ts.WriteLine Now & " - " & msg
    ts.Close
End Sub


---

Hướng dẫn test nhanh — từng bước

1. Mở workbook trong Excel (Visible = True). Chạy ExportSheetAsFile "Sheet1", "C:\Temp" (đảm bảo folder tồn tại).


2. Nếu lỗi: xem MsgBox và file log trong %TEMP%\ExportSheetAsFile-log.txt để biết Err.Number và mô tả.


3. Thử với tên sheet có ký tự đặc biệt để kiểm tra sanitize, ví dụ "My/Sheet:Test".


4. Nếu dùng UiPath:

Trong Excel Application Scope set Visible = True để quan sát.

Gọi macro bằng Execute Macro hoặc Invoke VBA (tránh dùng send keys).

Kiểm tra file log nếu macro bị crash khi chạy headless.





---

Lưu ý thêm

Nếu sheet chứa ActiveX controls hoặc các OLE objects hỏng, đôi khi ws.Copy sẽ gây lỗi. Trong trường hợp đó thử tạo workbook mới và copy range thay vì entire sheet. Mình có thể cung cấp phiên bản sử dụng copy range nếu bạn cần.

Nếu vẫn còn lỗi sau khi dùng code trên, paste Err.Number và Err.Description từ MsgBox hoặc dán ra vài dòng log từ file %TEMP%\ExportSheetAsFile-log.txt — mình sẽ đọc và sửa tiếp.


Muốn mình chuyển sang phương án copy chỉ dữ liệu (không copy object/ActiveX) để tránh lỗi do control hỏng không?
