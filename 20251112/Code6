Cập nhật script — Sleep khi idle và tự bật lại khi có hoạt động hoặc PAD chạy

Dưới đây là bản PowerShell hoàn chỉnh cập nhật theo yêu cầu mục 3: khi phát hiện không hoạt động >= 10 phút, script vào chế độ "sleep" (dừng auto-save nhưng vẫn giữ tray app); script sẽ tự bật lại (auto-resume) khi:
- có tương tác người dùng (chuột/phím), hoặc
- PAD được khởi động lại / xuất hiện lại.

Script giữ nguyên mọi tính năng trước: tray app, dashboard tooltip, retry/backoff, đếm lỗi liên tiếp và hỏi user khi restart PAD.

Lưu file, ví dụ AutoSavePADTrayAutoResume.ps1, rồi chạy bằng PowerShell.

`powershell

AutoSavePADTrayAutoResume.ps1
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
Import-Module BurntToast -ErrorAction SilentlyContinue

---------- Cấu hình mặc định ----------
$logPath = "$env:USERPROFILE\Documents\AutoSavePAD_Log.txt"
$idleLimitMs = 600000           # 10 phút không hoạt động
$defaultIntervalMs = 180000     # 3 phút mặc định
$defaultMaxRetries = 3
$defaultInitialBackoffMs = 300
$defaultMaxBackoffMs = 3000
$maxConsecutiveFailuresAlert = 5
$padExeCandidates = @(
    "$env:ProgramFiles\Power Automate Desktop\PAD.Console.Host.exe",
    "$env:ProgramFiles(x86)\Power Automate Desktop\PAD.Console.Host.exe"
)

---------- Runtime state ----------
$autoSaveEnabled = $false
$inSleepMode = $false           # true khi đã sleep do idle
$consecutiveFailures = 0
$successCount = 0
$failureCount = 0
$lastSuccessTime = $null

Settings (có thể thay đổi từ UI)
$settings = @{
    IntervalMs = $defaultIntervalMs
    MaxRetries = $defaultMaxRetries
    InitialBackoffMs = $defaultInitialBackoffMs
    MaxBackoffMs = $defaultMaxBackoffMs
    ScheduleStart = "00:00"
    ScheduleEnd   = "23:59"
}

---------- Helpers ----------
function Write-Log($message) {
    $ts = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $line = "$ts - $message"
    try { Add-Content -Path $logPath -Value $line } catch {}
    Write-Host $line
}

function Show-Toast($message) {
    try {
        New-BurntToastNotification -Text "Auto-Save PAD", $message
    } catch {
        $notify = New-Object System.Windows.Forms.NotifyIcon
        $notify.Icon = [System.Drawing.SystemIcons]::Information
        $notify.Visible = $true
        $notify.BalloonTipTitle = "Auto-Save PAD"
        $notify.BalloonTipText = $message
        $notify.ShowBalloonTip(3000)
        Start-Sleep -Seconds 3
        $notify.Dispose()
    }
}

---------- PAD checks ----------
function Get-PADMainProcess {
    Get-Process -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowTitle -like "Power Automate" } | Select-Object -First 1
}
function Is-PADRunning { return (Get-PADMainProcess) -ne $null }
function Is-FlowRunning {
    $host = Get-Process -ErrorAction SilentlyContinue | Where-Object { $.ProcessName -eq "PAD.Console.Host" -or $.ProcessName -like "PAD*" }
    return ($host -ne $null -and $host.Count -gt 0)
}
function Is-PADResponsive {
    $p = Get-PADMainProcess
    if (-not $p) { return $false }
    return $p.Responding
}

---------- Idle time ----------
function Get-IdleTime {
    $code = @'
    using System;
    using System.Runtime.InteropServices;
    public static class IdleTime {
        [DllImport("user32.dll")]
        static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);
        [StructLayout(LayoutKind.Sequential)]
        struct LASTINPUTINFO {
            public uint cbSize;
            public uint dwTime;
        }
        public static TimeSpan GetIdleTime() {
            LASTINPUTINFO lii = new LASTINPUTINFO();
            lii.cbSize = (uint)Marshal.SizeOf(typeof(LASTINPUTINFO));
            GetLastInputInfo(ref lii);
            return TimeSpan.FromMilliseconds(Environment.TickCount - lii.dwTime);
        }
    }
'@
    Add-Type -TypeDefinition $code -ErrorAction SilentlyContinue | Out-Null
    return [IdleTime]::GetIdleTime()
}

---------- Safe SendKeys helpers ----------
$null = Add-Type -MemberDefinition @"
using System;
using System.Runtime.InteropServices;
public static class WinAPI {
    [DllImport("user32.dll")]
    public static extern bool SetForegroundWindow(IntPtr hWnd);
}
"@ -Name "WinAPI" -Namespace "User32" -PassThru -ErrorAction SilentlyContinue

function Safe-BringPADToFront($padProcess) {
    try {
        [User32.WinAPI]::SetForegroundWindow($padProcess.MainWindowHandle) | Out-Null
        Start-Sleep -Milliseconds 300
        return $true
    } catch { return $false }
}

function Can-SendKeysToPAD {
    $p = Get-PADMainProcess
    if (-not $p) { return $false }
    if (-not $p.Responding) { return $false }
    if ([string]::IsNullOrWhiteSpace($p.MainWindowTitle)) { return $false }
    return $true
}

---------- Schedule check ----------
function Is-InSchedule {
    param($startTime,$endTime)
    $now = Get-Date
    $fmt = 'HH:mm'
    $s = [datetime]::ParseExact($startTime,$fmt,$null)
    $e = [datetime]::ParseExact($endTime,$fmt,$null)
    $todayS = Get-Date -Hour $s.Hour -Minute $s.Minute -Second 0
    $todayE = Get-Date -Hour $e.Hour -Minute $e.Minute -Second 0
    if ($todayS -le $todayE) {
        return ($now -ge $todayS -and $now -le $todayE)
    } else {
        return ($now -ge $todayS -or $now -le $todayE)
    }
}

---------- Retry save with backoff ----------
function Try-SendSave {
    param([int]$maxAttempts = $settings.MaxRetries, [int]$initialBackoff = $settings.InitialBackoffMs, [int]$maxBackoff = $settings.MaxBackoffMs)
    if (-not (Is-InSchedule $settings.ScheduleStart $settings.ScheduleEnd)) {
        Write-Log "Ngoài lịch lưu (${settings.ScheduleStart} - ${settings.ScheduleEnd}) -> bỏ qua"
        return $false
    }
    if (-not (Is-PADRunning)) {
        Write-Log "PAD chưa chạy — bỏ qua save"
        Show-Toast "PAD chưa chạy — Auto-Save chờ PAD"
        return $false
    }
    if (Is-FlowRunning) {
        Write-Log "Flow đang chạy — bỏ qua save"
        return $false
    }
    if (-not (Can-SendKeysToPAD)) {
        Write-Log "PAD không đáp ứng điều kiện gửi phím — bỏ qua"
        return $false
    }

    $attempt = 0
    $delay = [int]$initialBackoff
    while ($attempt -lt $maxAttempts) {
        $attempt++
        $padProcess = Get-PADMainProcess
        if (-not $padProcess) { Write-Log "Không tìm thấy cửa sổ PAD (lần $attempt)"; break }

        if (-not (Safe-BringPADToFront $padProcess)) {
            Write-Log "Không thể đưa PAD lên foreground (lần $attempt)"
        } else {
            try {
                [System.Windows.Forms.SendKeys]::SendWait("^s")
                Start-Sleep -Milliseconds 300
                Write-Log "Gửi Ctrl+S thành công (lần $attempt)"
                Show-Toast "Đã lưu flow lúc $(Get-Date -Format 'HH:mm:ss')"
                $script:consecutiveFailures = 0
                $script:successCount++
                $script:lastSuccessTime = Get-Date
                Update-Tooltip
                return $true
            } catch {
                Write-Log "Lỗi khi gửi Ctrl+S: $($_.Exception.Message)"
            }
        }
        Start-Sleep -Milliseconds $delay
        $delay = [math]::Min($maxBackoff, $delay * 2)
    }

    $script:consecutiveFailures++
    $script:failureCount++
    Update-Tooltip
    Write-Log "Không lưu được sau $attempt lần thử. Lỗi liên tiếp: $script:consecutiveFailures"
    Show-Toast "Auto-Save: không lưu được (lần thử $attempt)"
    return $false
}

---------- Restart PAD (hỏi user) ----------
function Find-PADExe {
    foreach ($p in $padExeCandidates) { if (Test-Path $p) { return $p } }
    $possible = Get-ChildItem "$env:ProgramFiles","$env:ProgramFiles(x86)" -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "Power Automate" } | Select-Object -First 1
    if ($possible) {
        $exe = Join-Path $possible.FullName "PAD.Console.Host.exe"
        if (Test-Path $exe) { return $exe }
    }
    return $null
}

function Prompt-And-RestartPAD {
    $res = [System.Windows.Forms.MessageBox]::Show("PAD có vẻ không phản hồi. Bạn có muốn khởi động lại PAD bây giờ?", "Khởi động lại PAD", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Warning)
    if ($res -eq [System.Windows.Forms.DialogResult]::Yes) {
        try {
            Get-Process -ErrorAction SilentlyContinue | Where-Object { $.ProcessName -like "PAD*" -or $.ProcessName -eq "PAD.Console.Host" } | Stop-Process -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 2
            $exe = Find-PADExe
            if ($exe) {
                Start-Process -FilePath $exe
                Write-Log "PAD đã được khởi động lại theo yêu cầu user"
                Show-Toast "Đã khởi động lại PAD"
                $script:consecutiveFailures = 0
            } else {
                Write-Log "Không tìm thấy file thực thi PAD để restart"
                Show-Toast "Không tìm thấy tệp thực thi PAD để khởi động lại"
            }
        } catch {
            Write-Log "Lỗi khi restart PAD: $_"
            Show-Toast "Lỗi khi khởi động lại PAD"
        }
    } else {
        Write-Log "Người dùng từ chối restart PAD"
    }
}

---------- Tray UI & Dashboard tooltip ----------
$notifyIcon = New-Object System.Windows.Forms.NotifyIcon
$notifyIcon.Icon = [System.Drawing.SystemIcons]::Application
$notifyIcon.Text = "Auto-Save PAD"
$notifyIcon.Visible = $true

function Update-Tooltip {
    $status = if ($autoSaveEnabled) { "ON" } elseif ($inSleepMode) { "SLEEP" } else { "OFF" }
    $tooltip = "Auto-Save: $statusnSuccess: $successCount; Fail: $failureCountnConsecFailures: $consecutiveFailures"
    $notifyIcon.Text = $tooltip.Substring(0,[math]::Min(63,$tooltip.Length))
    $notifyIcon.BalloonTipTitle = "Auto-Save PAD"
    $notifyIcon.BalloonTipText = "Status: $statusnSuccess: $successCountnFail: $failureCount`nConsecFailures: $consecutiveFailures"
}

Context menu
$menu = New-Object System.Windows.Forms.ContextMenuStrip
$miStatus = New-Object System.Windows.Forms.ToolStripMenuItem "Auto-Save: OFF"
$miStartStop = New-Object System.Windows.Forms.ToolStripMenuItem "Bật Auto-Save"
$miForceSave = New-Object System.Windows.Forms.ToolStripMenuItem "Force Save Now"
$miOpenLog = New-Object System.Windows.Forms.ToolStripMenuItem "Mở log"
$miSettings = New-Object System.Windows.Forms.ToolStripMenuItem "Cấu hình..."
$miAutoStartup = New-Object System.Windows.Forms.ToolStripMenuItem "Tạo shortcut khởi động cùng Windows"
$miExit = New-Object System.Windows.Forms.ToolStripMenuItem "Thoát"
$menu.Items.AddRange(@($miStatus,$miStartStop,$miForceSave,$miOpenLog,$miSettings,$miAutoStartup,$miExit))
$notifyIcon.ContextMenuStrip = $menu

---------- Main timer (auto-save) ----------
$timer = New-Object System.Windows.Forms.Timer
$timer.Interval = $settings.IntervalMs
$timer.Add_Tick({
    if (-not $autoSaveEnabled) { return }
    # If sleep mode engaged externally, ignore
    if ($inSleepMode) { return }

    $idle = Get-IdleTime()
    if ($idle.TotalMilliseconds -ge $idleLimitMs) {
        Write-Log "Idle $([math]::Round($idle.TotalMinutes,2)) phút -> vào Sleep mode"
        Show-Toast "Auto-Save tạm dừng do không hoạt động. App sẽ tự bật lại khi có tương tác hoặc PAD chạy."
        $inSleepMode = $true
        $autoSaveEnabled = $false
        $miStatus.Text = "Auto-Save: SLEEP"
        $miStartStop.Text = "Bật Auto-Save"
        $timer.Stop()
        Update-Tooltip
        return
    }

    if (-not (Is-InSchedule $settings.ScheduleStart $settings.ScheduleEnd)) {
        Write-Log "Ngoài lịch lưu -> chờ"
        return
    }

    if (-not (Is-PADRunning)) {
        Write-Log "PAD chưa chạy — chờ PAD"
        return
    }

    if (-not (Is-PADResponsive)) {
        Write-Log "Phát hiện PAD có thể không phản hồi"
        Prompt-And-RestartPAD
        return
    }

    $ok = Try-SendSave -maxAttempts $settings.MaxRetries -initialBackoff $settings.InitialBackoffMs -maxBackoff $settings.MaxBackoffMs
    if (-not $ok) {
        if ($consecutiveFailures -ge $maxConsecutiveFailuresAlert) {
            Show-Toast "Cảnh báo cấp cao: Không lưu được liên tiếp $consecutiveFailures lần"
            Write-Log "Cảnh báo cấp cao: $consecutiveFailures lỗi liên tiếp"
        }
    }
})

---------- Idle-watch timer (kiểm tra để auto-resume) ----------

Thực hiện kiểm tra nhẹ mỗi 5s để phát hiện hoạt động người dùng hoặc PAD bắt đầu chạy lại
$idleWatcher = New-Object System.Windows.Forms.Timer
$idleWatcher.Interval = 5000
$idleWatcher.Add_Tick({
    if (-not $inSleepMode) { return }

    # Nếu PAD xuất hiện/đang chạy -> resume
    if (Is-PADRunning) {
        Write-Log "Phát hiện PAD chạy lại -> resume auto-save"
        Show-Toast "Phát hiện PAD — Auto-Save tự bật lại"
        $inSleepMode = $false
        $autoSaveEnabled = $true
        $miStatus.Text = "Auto-Save: ON"
        $miStartStop.Text = "Tắt Auto-Save"
        $timer.Interval = $settings.IntervalMs
        $timer.Start()
        Update-Tooltip
        return
    }

    # Nếu có hoạt động người dùng (idle < idleLimit) -> resume
    $idle = Get-IdleTime()
    if ($idle.TotalMilliseconds -lt $idleLimitMs) {
        Write-Log "Phát hiện hoạt động người dùng (idle $([math]::Round($idle.TotalSeconds,1))s) -> resume auto-save"
        Show-Toast "Phát hiện tương tác — Auto-Save tự bật lại"
        $inSleepMode = $false
        $autoSaveEnabled = $true
        $miStatus.Text = "Auto-Save: ON"
        $miStartStop.Text = "Tắt Auto-Save"
        $timer.Interval = $settings.IntervalMs
        $timer.Start()
        Update-Tooltip
        return
    }

    # Nếu không, tiếp tục sleep và chờ
})

---------- Settings window ----------
function Show-SettingsWindow {
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "Cấu hình Auto-Save PAD"
    $form.Size = New-Object System.Drawing.Size(420,340)
    $form.StartPosition = "CenterScreen"

    $lblInterval = New-Object System.Windows.Forms.Label
    $lblInterval.Text = "Chu kỳ lưu (phút):"
    $lblInterval.Location = New-Object System.Drawing.Point(20,20)
    $form.Controls.Add($lblInterval)

    $numInterval = New-Object System.Windows.Forms.NumericUpDown
    $numInterval.Minimum = 1
    $numInterval.Maximum = 120
    $numInterval.Value = int
    $numInterval.Location = New-Object System.Drawing.Point(160,18)
    $form.Controls.Add($numInterval)

    $lblRetries = New-Object System.Windows.Forms.Label
    $lblRetries.Text = "Max retry khi thất bại:"
    $lblRetries.Location = New-Object System.Drawing.Point(20,60)
    $form.Controls.Add($lblRetries)

    $numRetries = New-Object System.Windows.Forms.NumericUpDown
    $numRetries.Minimum = 0
    $numRetries.Maximum = 10
    $numRetries.Value = [int]$settings.MaxRetries
    $numRetries.Location = New-Object System.Drawing.Point(160,58)
    $form.Controls.Add($numRetries)

    $lblInitBack = New-Object System.Windows.Forms.Label
    $lblInitBack.Text = "Initial backoff (ms):"
    $lblInitBack.Location = New-Object System.Drawing.Point(20,100)
    $form.Controls.Add($lblInitBack)

    $txtInitBack = New-Object System.Windows.Forms.TextBox
    $txtInitBack.Text = $settings.InitialBackoffMs.ToString()
    $txtInitBack.Location = New-Object System.Drawing.Point(160,98)
    $form.Controls.Add($txtInitBack)

    $lblMaxBack = New-Object System.Windows.Forms.Label
    $lblMaxBack.Text = "Max backoff (ms):"
    $lblMaxBack.Location = New-Object System.Drawing.Point(20,140)
    $form.Controls.Add($lblMaxBack)

    $txtMaxBack = New-Object System.Windows.Forms.TextBox
    $txtMaxBack.Text = $settings.MaxBackoffMs.ToString()
    $txtMaxBack.Location = New-Object System.Drawing.Point(160,138)
    $form.Controls.Add($txtMaxBack)

    $lblSchedule = New-Object System.Windows.Forms.Label
    $lblSchedule.Text = "Lịch lưu (HH:mm):"
    $lblSchedule.Location = New-Object System.Drawing.Point(20,180)
    $form.Controls.Add($lblSchedule)

    $txtStart = New-Object System.Windows.Forms.TextBox
    $txtStart.Text = $settings.ScheduleStart
    $txtStart.Location = New-Object System.Drawing.Point(160,178)
    $txtStart.Width = 80
    $form.Controls.Add($txtStart)

    $lblTo = New-Object System.Windows.Forms.Label
    $lblTo.Text = "đến"
    $lblTo.Location = New-Object System.Drawing.Point(250,180)
    $form.Controls.Add($lblTo)

    $txtEnd = New-Object System.Windows.Forms.TextBox
    $txtEnd.Text = $settings.ScheduleEnd
    $txtEnd.Location = New-Object System.Drawing.Point(290,178)
    $txtEnd.Width = 80
    $form.Controls.Add($txtEnd)

    $btnSave = New-Object System.Windows.Forms.Button
    $btnSave.Text = "Lưu"
    $btnSave.Location = New-Object System.Drawing.Point(160,240)
    $btnSave.Size = New-Object System.Drawing.Size(80,30)
    $form.Controls.Add($btnSave)

    $btnCancel = New-Object System.Windows.Forms.Button
    $btnCancel.Text = "Hủy"
    $btnCancel.Location = New-Object System.Drawing.Point(260,240)
    $btnCancel.Size = New-Object System.Drawing.Size(80,30)
    $form.Controls.Add($btnCancel)

    $btnSave.Add_Click({
        try {
            $newIntervalMin = [int]$numInterval.Value
            $settings.IntervalMs = $newIntervalMin * 60000
            $timer.Interval = $settings.IntervalMs

            $settings.MaxRetries = [int]$numRetries.Value
            $settings.InitialBackoffMs = [int]$txtInitBack.Text
            $settings.MaxBackoffMs = [int]$txtMaxBack.Text

            [void][datetime]::ParseExact($txtStart.Text,'HH:mm',$null)
            [void][datetime]::ParseExact($txtEnd.Text,'HH:mm',$null)
            $settings.ScheduleStart = $txtStart.Text
            $settings.ScheduleEnd = $txtEnd.Text

            Write-Log "Cập nhật cấu hình: Interval=${settings.IntervalMs}ms, Retries=${settings.MaxRetries}, Backoff=${settings.InitialBackoffMs}-${settings.MaxBackoffMs}ms, Schedule=${settings.ScheduleStart}-${settings.ScheduleEnd}"
            Show-Toast "Đã lưu cấu hình Auto-Save"
            Update-Tooltip
            $form.Close()
        } catch {
            [System.Windows.Forms.MessageBox]::Show("Giá trị nhập không hợp lệ. Vui lòng kiểm tra lại.", "Lỗi", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        }
    })

    $btnCancel.Add_Click({ $form.Close() })
    $form.Topmost = $true
    $form.ShowDialog()
}

---------- Menu handlers ----------
$miStartStop.Add_Click({
    $autoSaveEnabled = -not $autoSaveEnabled
    if ($autoSaveEnabled) {
        # cannot enable if currently in sleep; resume handled by idleWatcher
        if ($inSleepMode) {
            Show-Toast "Ứng dụng đang ở chế độ Sleep do idle; nó sẽ tự bật lại khi có tương tác hoặc PAD chạy."
            $autoSaveEnabled = $false
            return
        }
        $miStatus.Text = "Auto-Save: ON"
        $miStartStop.Text = "Tắt Auto-Save"
        $timer.Interval = $settings.IntervalMs
        $timer.Start()
        Write-Log "Auto-Save bật (interval=${settings.IntervalMs}ms)"
        Show-Toast "Auto-Save đã bật"
    } else {
        $miStatus.Text = "Auto-Save: OFF"
        $miStartStop.Text = "Bật Auto-Save"
        $timer.Stop()
        Write-Log "Auto-Save tắt"
        Show-Toast "Auto-Save đã tắt"
    }
    Update-Tooltip
})

$miForceSave.Add_Click({
    Write-Log "Force Save từ tray"
    Try-SendSave -maxAttempts $settings.MaxRetries -initialBackoff $settings.InitialBackoffMs -maxBackoff $settings.MaxBackoffMs | Out-Null
})

$miOpenLog.Add_Click({
    try {
        if (-not (Test-Path $logPath)) { New-Item -Path $logPath -ItemType File -Force | Out-Null }
        Start-Process -FilePath "notepad.exe" -ArgumentList $logPath
    } catch { Write-Log "Không thể mở log: $_" }
})

$miSettings.Add_Click({ Show-SettingsWindow })

$miAutoStartup.Add_Click({
    try {
        $startup = [Environment]::GetFolderPath("Startup")
        $shortcutPath = Join-Path $startup "AutoSavePAD - Shortcut.lnk"
        $psExe = (Get-Command powershell).Source
        $scriptPath = $MyInvocation.MyCommand.Path
        $wsh = New-Object -ComObject WScript.Shell
        $sc = $wsh.CreateShortcut($shortc
